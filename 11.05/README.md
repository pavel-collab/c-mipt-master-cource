# Применение паттерна Visitor для проектирования систем

## Краткое описание

Паттерн _visitor_ -- это поведенческий паттерн проектирования, который позволяет добавлять новые операции к объектам без изменения их классов.

## Проблематика

Представим, что мы разрабатываем программу, в которой требуется выполнять операции с различными геометрическими фигурами.
Логично, что стоит реализовать какой-нибудь базовый интерфейс Shape и определить в нем интерфейсные методы, а затем
для каждой геометрической фигуры отнаследовать отдельный класс и написать реализацию метода для каждой геометрической фигуры.

Предположим, что каждая фигура инкапсулирует в себе поля, которые определяют ее положение в простанстве (пусть это будут, 
например, координаты цетра и параметры фигуры), а в качестве метода возьмем операци отрисовки фигуры на некотором графическом 
фрейме (например мы пишем математическую библиотеку с дополнительной функцией визуализации). Тогда для каждого отнаследованного
класса фигуры нам надо отдельно писать реализацию метода Draw. 

Таким образом, здесь нарушается принцип единой ответственности объекта. Если объект хранит свои инварианты, кажется, что он
не обязан знать, как и каким образом рисовать себя н каком-то там фрейме. А если у интерфейса есть еще и другие методы 
(например, методы расчета периметра, площади, пересечения с другими фигурами), то принцип единой ответсвенности точно наруен.
Более того, если в какой-то момент разработки мы захотим перейти на другой графический движок, придется менять каждую реализацию
каждого отнаследованного класса каждой фигуры. Другими словами, придется лезть внуторь реализации, а как мы помним, классы должны
быть открыты для расширения, но закрыты для модификации.

## Детальное описание

Паттерн _visitor_ можно использовать, когда есть набор объектов, и нам нужно выполнить некоторые действия над этими объектами,
не изменяя их внутренюю структуру (отрисовка, расчет площади и т п). Для этого создается отдельный объект, который выполняет
орперации над данными ему объектами.

Преимущества такого подхода:
- мы не нарушаем принцип ООП о приципе ограниченной ответственноти
- мы не нарушаем принцип SOLID о закрытости интерфейса к модификации
- мы получаем легкую расширяемость, так как под каждую отдельную операцию над коллекцией объектов можно просто создавать отдельного  _visitor_

## Пример применения паттерна

В качестве примера сделаем интерфейсный класс объекта и отнаследуем от него различные геометрические фигуры. Предположим, что для каждой фигуры мы хотим расчитывать площадь и периметр. Создадим интерфейсный объект Visitor и для каждой отдельной операции отнаследуем от него отдельного Visitor. 
Заметим, что прицип открытости-закрытости здесь не нарушается. Если нам понадобится дополнительная операция над объектами,
мы просто отнаследуем нового Visitor (расширение, но не модификация). Если у нас появится новая геометрическая фигура, мы для
каждого visitor допишем методы для этой фигуры (расширение, но не модификация).